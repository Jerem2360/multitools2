from typing import Any, Protocol, final, Callable, TypeVar
from ctypes import Array as _stdArr


class _ModuleSpec(Protocol):
    @classmethod
    def exec_module(cls, module): ...
    name: str = ...
    loader: Any = ...
    origin: str | None = ...
    submodule_search_locations: list[str] | None = ...
    loader_state: Any | None = ...
    cached: str | None = ...
    parent: str = ...
    has_location: bool = ...


class _Iterator(Protocol):
    """Generic protocol for all iterator types."""
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...


_Reduced = TypeVar("_Reduced", bound=tuple[Callable, tuple, ...])


class Module(object):
    def __init__(self, name: str, doc: Any = ...) -> None:
        self.__annotations__: dict[str, Any] = ...
        self.__dict__: dict[str, Any] = ...
        self.__doc__: str | None = ...

    def __new__(cls, name: str, doc: Any | None = ...) -> Module: ...
    def __delattr__(self, name: str) -> None: ...
    def __dir__(self) -> list[str]: ...
    def __getattribute__(self, name: str) -> Any: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    __spec__: _ModuleSpec = ...
    __loader__: Any | None = ...
    __file__: str | None = ...
    __path__: list[str] | None = ...
    __cached__: str | None = ...
    __package__: str = ...  # only defined for package modules.


class CArgObject(object):  # real value is <class 'CArgObject'> (from '_ctypes' extension)
    def __repr__(self) -> str: ...
    _obj: Any | None = ...


class PyCSimpleType(type):  # real value is <class '_ctypes.PyCSimpleType'>
    def __mul__(cls, other: Any) -> Any: ...
    def __rmul__(cls, other: Any) -> Any: ...
    def from_address(cls, address: int) -> SimpleCData: ...
    def from_buffer(cls, ob: Any, offset: int = ...) -> SimpleCData: ...
    def from_buffer_copy(cls, ob: Any, offset: int = ...) -> SimpleCData: ...
    def from_param(cls, param: Any) -> CArgObject: ...


class CData(object):  # real value is <class '_ctypes._CData'>
    def __ctypes_from_outparam__(self) -> CData: ...
    def __reduce__(self) -> _Reduced: ...
    def __setstate__(self, _dict: dict, data: str, len: int) -> None: ...
    _b_base_: CData = ...
    _b_needsfree_: int = ...
    _objects: list[Any] = ...


class SimpleCData(CData, metaclass=PyCSimpleType):  # real value is <class '_ctypes._SimpleCData'>
    def __bool__(self) -> bool: ...
    def __repr__(self) -> str: ...
    # noinspection PyMethodParameters
    @staticmethod
    def __new__(*args, **kwargs) -> SimpleCData: ...
    def __init__(self, value: Any) -> None: ...
    def __mul__(self, other: int) -> type[_stdArr]: ...
    value: Any = ...


class Code(object):
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getattribute__(self, item: str) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __new__(cls, *args, **kwargs): ...
    def __repr__(self) -> str: ...
    def __sizeof__(self) -> int: ...
    def co_lines(self) -> _Iterator: ...
    def replace(self, /, *, co_argcount: int = ..., co_posonlyargcount: int = ..., co_kwonlyargcount: int = ...,
                co_nlocals: int = ..., co_stacksize: int = ..., co_flags: int = ..., co_firstlineno: int = ...,
                co_code: bytes | None = ..., co_consts: tuple[str, ...] | None = ..., co_names: tuple[str, ...] | None = ...,
                co_varnames: tuple[str, ...] | None, co_freevars: tuple[str, ...] | None,
                co_cellvars: tuple[str, ...] | None = ..., co_filename: str | None = ..., co_name: str | None = ...,
                co_linetable: bytes | None = ...) -> None: ...
    co_argcount: int = ...
    co_cellvars: tuple[str, ...] | None = ...
    co_code: bytes = ...
    co_consts: tuple[str, ...] | None = ...
    co_filename: str = ...
    co_firstlineno: int = ...
    co_flags: int = ...
    co_freevars: tuple[str, ...] | None = ...
    co_kwonlyargcount: int = ...
    co_linetable: bytes = ...
    co_lnotab: bytes = ...
    co_name: str = ...
    co_names: tuple[str, ...] | None = ...
    co_nlocals: int = ...
    co_posonlyargcount: int = ...
    co_stacksize: int = ...
    co_varnames: tuple[str, ...] | None = ...


@final
class Function(object):
    __annotations__: dict[str, type] = ...
    __builtins__: dict[str, Any] = ...
    __closure__: tuple[Cell, ...] | None = ...
    __code__: Code = ...
    __defaults__: tuple[Any, ...] | None = ...
    __globals__: dict[str, Any] = ...
    __kwdefaults__ = ...
    __module__: str = ...
    __name__: str = ...
    __qualname__: str = ...

    def __call__(self, *args, **kwargs) -> Any: ...
    def __get__(self, instance: Any, owner: type) -> Any: ...
    def __repr__(self) -> str: ...
    def __new__(cls, code: Code | None, globals: dict[str, Any], name: str = ..., argdefs: tuple[Any, ...] | None = ...,
                closure: tuple[Cell, ...] | None = ...) -> Function: ...


@final
class Method(object):
    __func__: Function = ...
    __self__: Any = ...
    __annotations__: dict[str, type] = ...
    __builtins__: dict[str, Any] = ...
    __closure__: tuple[Cell, ...] | None = ...
    __code__: Code = ...
    __defaults__: tuple[Any, ...] | None = ...
    __globals__: dict[str, Any] = ...
    __kwdefaults__ = ...
    __module__: str = ...
    __name__: str = ...
    __qualname__: str = ...

    def __call__(self, *args, **kwargs) -> Any: ...
    def __delattr__(self, item: str) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __get__(self, instance: Any, owner: type) -> Any: ...
    def __getattribute__(self, item: str) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> Any: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __reduce__(self) -> _Reduced: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def __new__(cls, function: Function, instance: Any) -> Method: ...


@final
class Frame(object):
    def __delattr__(self, name: str) -> None: ...
    def __getattribute__(self, name: str) -> Any: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __sizeof__(self) -> int: ...
    def clear(self) -> None: ...
    f_back: Frame | None = ...
    f_builtins: dict[str, Any] = ...
    f_code: Code = ...
    f_globals: dict[str, Any] = ...
    f_lasti: int = ...
    f_lineno: int = ...
    f_locals: dict[str, Any] = ...
    f_trace: Any | None = ...
    f_trace_lines: bool = ...
    f_trace_opcodes: bool = ...


@final
class Traceback(object):
    def __dir__(self) -> list[str]: ...
    def __getattribute__(self, name: str) -> Any: ...
    def __repr__(self) -> str: ...
    def __new__(cls, tb_next: Traceback | None, tb_frame: Frame, tb_lasti: int, tb_lineno: int) -> Traceback: ...
    tb_frame: Frame = ...
    tb_lasti: int = ...
    tb_lineno: int = ...
    tb_next: Traceback | None = ...


class Cell(object):
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getattribute__(self, item: str) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __new__(cls, __contents: Any = ...) -> Cell: ...
    cell_contents: Any = ...


@final
class MethodWrapper(object):
    def __call__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __getattribute__(self, item: str) -> Any: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> _Reduced: ...
    def __repr__(self) -> str: ...
    __objclass__: type = ...
    __self__: object = ...
    __text_signature__: str = ...


@final
class WrapperDescriptor(object):
    def __call__(self, *args, **kwargs) -> Any: ...
    def __get__(self, instance: object, owner: type) -> Any: ...
    def __getattribute__(self, item: str) -> Any: ...
    def __reduce__(self) -> _Reduced: ...
    def __repr__(self) -> str: ...
    __objclass__: type = ...
    __text_signature__: str = ...

