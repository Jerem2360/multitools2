from .._meta import *
from typing import overload, Union, Any, Callable


class CData(object):
    def __ctypes_from_outparam__(self, *args, **kwargs) -> Any: ...
    def __hash__(self) -> str: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state: Any) -> Any: ...


class PyCFuncPtrType(type):
    # noinspection PyMissingConstructor
    def __init__(cls, *args, **kwargs) -> None: ...
    def __mul__(cls, value: int) -> type: ...
    def __rmul__(cls, value: int) -> type: ...
    def from_address(cls, address: int) -> CData: ...
    def from_buffer(cls, obj, offset: int = ...) -> CData: ...
    def from_buffer_copy(cls, obj, offset: int = ...) -> CData: ...
    def from_param(cls) -> Union[int, bytes]: ...
    def in_dll(cls, dll: type, name: str) -> CData: ...
    # noinspection PyMethodParameters
    @staticmethod
    def __new__(*args, **kwargs) -> PyCFuncPtrType: ...


class CFuncPtr(CData, metaclass=PyCFuncPtrType):
    def __bool__(self) -> bool: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __repr__(self) -> str: ...
    # noinspection PyMethodParameters
    @staticmethod
    def __new__(*args, **kwargs) -> CFuncPtr: ...

    argtypes: tuple[type] = ...
    errcheck: Callable[[int, CFuncPtr, tuple], None] = ...
    restype: type = ...


class Library(metaclass=MultiMeta):
    def __init__(self, handle: int) -> None: ...
    def free(self) -> None: ...
    @overload
    def getfunc(self, name: str, flags: int = ...) -> CFuncPtr: ...
    @overload
    def getfunc(self, ordinal: int, flags: int = ...) -> CFuncPtr: ...
    @staticmethod
    def load(path: str, flags: int = ...) -> Library: ...

