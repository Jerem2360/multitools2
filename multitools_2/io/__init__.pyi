from typing import IO, TypeVar, overload, Iterable

_T = TypeVar('_T', str, bytes, covariant=True)


class Stream(IO[_T]):
    @overload
    def __init__(self, source: IO[_T]) -> None: ...  # (!) real signature is __init__(self, source: io.IOBase) -> None
    @overload
    def __init__(self, fd: int, readable: bool = ..., writable: bool = ..., name: str | None = ...) -> None: ...
    def __write__(self, data: _T) -> int: ...
    def __read__(self, size: int) -> _T: ...
    def __close__(self) -> None: ...
    def __fileno__(self) -> int: ...
    def __flush__(self) -> None: ...
    def __isatty__(self) -> bool: ...
    def read(self, size: int = ...) -> _T: ...
    def readline(self, **kwargs) -> _T: ...
    def readlines(self, hint: int = ...) -> list[_T]: ...
    def write(self, data: _T) -> int: ...
    def writelines(self, lines: Iterable[_T]) -> None: ...
    def close(self) -> None: ...
    def fileno(self) -> int: ...
    def detach(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def tell(self) -> int: ...
    def truncate(self, size: int | None = ...) -> int: ...
    def __repr__(self) -> str: ...
    closed: bool = ...
    name: str = ...


class File(Stream):
    def __init__(self, descr: int, readable: bool, writable: bool) -> None: ...
    @classmethod
    def open(cls, filename: str, mode: str = ...) -> File: ...


class Pipe(Stream):
    def __new__(cls, *args, **kwargs) -> tuple[Pipe, Pipe]: ...
    def __init__(self, *args, **kwargs) -> None: ...

