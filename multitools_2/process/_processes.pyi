from typing import overload, Any
from types import FunctionType, CellType, CodeType


class Process:
    @overload
    def __new__(
            cls, target: FunctionType = ..., pid: int = ..., distant: bool = ..., daemon: bool = ..., pipe_read: int = ...,
            pipe_write: int = ..., pipe_err: int = ..., *args, **kwargs
    ) -> Process: ...
    @overload
    def __new__(
            cls, command: str, target: FunctionType = ..., daemon: bool = ..., pipe_read: int = ...,
            pipe_write: int = ..., pipe_err: int = ..., *args, **kwargs
    ) -> Process: ...
    @overload
    def __init__(
            self, target: FunctionType = ..., pid: int = ..., distant: bool = ..., daemon: bool = ..., pipe_read: int = ...,
            pipe_write: int = ..., pipe_err: int = ..., *args, **kwargs
    ) -> None:
        self.__name__: str = ...
        self.__qualname__: str = ...
        self.__defaults__: tuple = ...
        self.__kwdefaults__: dict[str, Any] = ...
        self.__annotations__: dict[str, Any] = ...
        self.__closure__: tuple[CellType, ...] | None = ...
        self.__code__: CodeType | None = ...
        self.__globals__: dict[str, Any] = ...
        self.__module__: str = ...
    @overload
    def __init__(
            self, command: str, target: FunctionType = ..., daemon: bool = ..., pipe_read: int = ...,
            pipe_write: int = ..., pipe_err: int = ..., *args, **kwargs
    ) -> None: ...
    def __call__(self, *args, **kwargs) -> Process: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]) -> None: ...
    @staticmethod
    def main_process() -> Process: ...
    def terminate(self) -> bool: ...
    def kill(self) -> bool: ...
    @classmethod
    def current_process(cls) -> Process: ...
    @classmethod
    def __open__(cls, pid: int) -> Process: ...
    def __repr__(self) -> str: ...

    pid: int = ...
    state: int = ...


def __finalize__() -> None: ...

