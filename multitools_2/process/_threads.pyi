from typing import Callable, Any, overload, Protocol
from types import TracebackType, FrameType


class _ExecutionInfo(Protocol):
    result: Any = ...


class _Lock:
    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...
    def release(self) -> None: ...
    def locked(self) -> bool: ...
    def __enter__(self) -> bool: ...
    def __exit__(
        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None
    ) -> None: ...


class Thread:
    __tstate__: int = ...
    __callable__: Callable[[Thread, ...], Any]
    __join_lock__: _Lock = ...
    __daemon__: bool = ...
    __result__: Any = ...

    def __init__(self, activity: Callable[[Thread, ...], Any], daemon: bool = ...) -> None: ...
    @classmethod
    @overload
    def __obtain__(cls, id_: int, tstate: int = ..., distance: dict[str, Any] = ...) -> Thread: ...
    @classmethod
    @overload
    def __obtain__(
            cls, id_: int = ..., tstate: int = ..., callable_: Callable[[Thread, ...], Any] = ..., lock: _Lock = ...,
            daemon: bool = ..., is_main: bool = ..., distance: dict[str, Any] = ...
    ) -> Thread: ...
    def __call__(self, *args, **kwargs) -> Thread: ...
    def __repr__(self) -> str: ...
    def join(self) -> None: ...
    def invoke(self, function: Callable, *args, **kwargs) -> _ExecutionInfo: ...
    def settrace(self, tracefunc: Callable[[FrameType, str, tuple], Any]) -> None: ...
    def gettrace(self) -> Callable[[FrameType, str, tuple], Any]: ...
    def exc_info(self) -> tuple[type[Exception] | None, Exception | None, TracebackType | None]: ...
    @staticmethod
    def get_main() -> Thread: ...

    state: str = ...
    id: int = ...
    daemon: bool = ...
    result: Any = ...


def __finalize__() -> None: ...

