from dataclasses import dataclass as _dataclass
from typing import Any as _Any, Optional as _Optional
from types import CodeType as _CodeType
import types as _t


def getattr_root(tp: _MultiClass, name: str) -> _Any: ...

def setattr_root(tp: _MultiClass, name: str, value: _Any) -> None: ...


@_dataclass
class _ClassData:
    name: str
    bases: tuple[type]
    original_dict: dict
    main_base: type
    is_abstract: bool

    def __repr__(self) -> str: ...


class AbstractMethodDescriptor:
    def __init__(self, func: callable):
        self.__name__: str = ...
        self.overridden : bool = ...
        self.__annotations__: dict = ...
        self.__code__: _Optional[_CodeType] = ...
        self.__closure__: tuple[getattr(_t, "CellType")] = ...
        self.__defaults__: tuple = ...
        self.__globals__: dict[str, _Any] = ...
        self.__kwdefaults__: dict[str, _Any] = ...

    def __call__(self, *args, **kwargs) -> _Any: ...

    def override(self, value: callable) -> None: ...



class MultiMeta(type):
    # noinspection PyMissingConstructor
    def __init__(cls, name: str, bases: tuple[type], dct: dict[str, _Any]):
        cls.__class_data__: _ClassData = ...
    def __getattr__(self, item: str, **kwargs) -> _Any: ...
    def __repr__(self) -> str: ...


_MultiClass = type[MultiMeta]

